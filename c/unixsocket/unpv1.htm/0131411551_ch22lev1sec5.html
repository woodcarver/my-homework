<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="22.5 Adding Reliability to a UDP Application"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch22lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch22lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch22lev1sec5"></A>
<H3 class="docSection1Title">22.5 Adding Reliability to a UDP Application</H3>
<P class="docText">If we are going to use UDP for a request-reply application, as mentioned in the previous section, then we <span class="docEmphasis">must</span> add two features to our client:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Timeout and retransmission to handle datagrams that are discarded</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Sequence numbers so the client can verify that a reply is for the appropriate request</P></span></LI></OL></span>
<P class="docText">These two features are part of most existing UDP applications that use the simple request-reply paradigm: DNS resolvers, SNMP agents, TFTP, and RPC, for example. We are not trying to use UDP for bulk data transfer; our intent is for an application that sends a request and waits for a reply.</P>
<BLOCKQUOTE><P><P class="docList">By definition, a datagram is unreliable; therefore, we purposely do not call this a "reliable datagram service." Indeed, the term "reliable datagram" is an oxymoron. What we are showing is an application that adds reliability on top of an unreliable datagram service (UDP).</P></P></BLOCKQUOTE>
<P class="docText">Adding sequence numbers is simple. The client prepends a sequence number to each request and the server must echo this number back to the client in the reply. This lets the client verify that a given reply is for the request that was issued.</P>
<P class="docText">The old-fashioned method for handling timeout and retransmission was to send a request and wait for <span class="docEmphasis">N</span> seconds. If no response was received, retransmit and wait another <span class="docEmphasis">N</span> seconds. After this had happened some number of times, the application gave up. This is an example of a linear retransmit timer. (Figure 6.8 of TCPv1 shows an example of a TFTP client that uses this technique. Many TFTP clients still use this method).</P>
<P class="docText">The problem with this technique is that the amount of time required for a datagram to make a round trip on a network can vary from fractions of a second on a LAN to many seconds on a WAN. Factors affecting the RTT are distance, network speed, and congestion. Additionally, the RTT between a client and server can change rapidly with time, as network conditions change. We must use a timeout and retransmission algorithm that take into account the actual RTTs that we measure along with the changes in the RTT over time. Much work has been focused on this area, mostly relating to TCP, but the same ideas apply to any network application.</P>
<P class="docText">We want to calculate the RTO to use for every packet that we send. To calculate this, we measure the RTT: the actual round-trip time for a packet. Every time we measure an RTT, we update two statistical estimators: <span class="docEmphasis">srtt</span> is the smoothed RTT estimator and <span class="docEmphasis">rttvar</span> is the smoothed mean deviation estimator. The latter is a good approximation of the standard deviation, but easier to compute since it does not involve a square root. Given these two estimators, the <span class="docEmphasis">RTO</span> to use is <span class="docEmphasis">srtt</span> plus four times <span class="docEmphasis">rttvar</span>. [Jacobson 1988] provides all the details of these calculations, which we can summarize in the following four equations:</P>


<p class="docText">
<IMG BORDER="0" WIDTH="207" HEIGHT="86" src="FILES/598equ01.gif" ALT="graphics/598equ01.gif"></p>
<br>
<P class="docText"><span class="docEmphasis">delta</span> is the difference between the measured RTT and the current smoothed RTT estimator (<span class="docEmphasis">srtt</span>). <span class="docEmphasis">g</span> is the gain applied to the RTT estimator and equals 1/8. <span class="docEmphasis">h</span> is the gain applied to the mean deviation estimator and equals 1/4.</P>
<BLOCKQUOTE><P><P class="docList">The two gains and the multiplier 4 in the <span class="docEmphasis">RTO</span> calculation are purposely powers of 2 so they can be calculated using shift operations instead of multiplying or dividing. Indeed, the TCP kernel implementation (Section 25.7 of TCPv2) is normally performed using fixed-point arithmetic for speed, but for simplicity, we use floating-point calculations in our code that follows.</P></P></BLOCKQUOTE>
<P class="docText">Another point made in [Jacobson 1988] is that when the retransmission timer expires, an <span class="docEmphasis">exponential backoff</span> must be used for the next <span class="docEmphasis">RTO</span>. For example, if our first <span class="docEmphasis">RTO</span> is 2 seconds and the reply is not received in this time, then the next <span class="docEmphasis">RTO</span> is 4 seconds. If there is still no reply, the next <span class="docEmphasis">RTO</span> is 8 seconds, and then 16, and so on.</P>
<P class="docText">Jacobson's algorithms tell us how to calculate the <span class="docEmphasis">RTO</span> each time we measure an RTT and how to increase the <span class="docEmphasis">RTO</span> when we retransmit. But, a problem arises when we have to retransmit a packet and then receive a reply. This is called the <span class="docEmphasis">retransmission ambiguity problem</span>. <A class="docLink" HREF="#ch22fig05">Figure 22.5</A> shows the following three possible scenarios when our retransmission timer expires:</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch22fig05"></A>Figure 22.5. Three scenarios when retransmission timer expires.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="179" src="FILES/22fig05.gif" ALT="graphics/22fig05.gif"></p>

</CENTER>
<UL><LI><P class="docList">The request is lost</P></LI><LI><P class="docList">The reply is lost</P></LI><LI><P class="docList">The <span class="docEmphasis">RTO</span> is too small</P></LI></UL>
<P class="docText">When the client receives a reply to a request that was retransmitted, it cannot tell to which request the reply corresponds. In the example on the right, the reply corresponds to the original request, while in the two other examples, the reply corresponds to the retransmitted request.</P>
<P class="docText"><span class="docEmphasis">Karn's algorithm</span> [Karn and Partridge 1991] handles this scenario with the following rules that apply whenever a reply is received for a request that was retransmitted:</P>
<UL><LI><P class="docList">If an RTT was measured, do not use it to update the estimators since we do not know to which request the reply corresponds.</P></LI><LI><P class="docList">Since this reply arrived before our retransmission timer expired, reuse this <span class="docEmphasis">RTO</span> for the next packet. Only when we receive a reply to a request that is not retransmitted will we update the RTT estimators and recalculate the <span class="docEmphasis">RTO</span>.</P></LI></UL>
<P class="docText">It is not hard to take Karn's algorithm into account when coding our RTT functions, but it turns out that an even better and more elegant solution exists. This solution is from the TCP extensions for "long fat pipes" (networks with either a high bandwidth, a long RTT, or both), which are documented in RFC 1323 [Jacobson, Braden, and Borman 1992]. In addition to prepending a sequence number to each request, which the server must echo back, we also prepend a <span class="docEmphasis">timestamp</span> that the server must also echo. Each time we send a request, we store the current time in the timestamp. When a reply is received, we calculate the RTT of that packet as the current time minus the timestamp that was echoed by the server in its reply. Since every request carries a timestamp that is echoed by the server, we can calculate the RTT of <span class="docEmphasis">every</span> reply we receive. There is no longer any ambiguity at all. Furthermore, since all the server does is echo the client's timestamp, the client can use any units desired for the timestamps and there is no requirement at all that the client and server have synchronized clocks.</P>
<A NAME="ch22lev2sec2"></A>
<H4 class="docSection2Title"> Example</H4>
<P class="docText">We will now put all of this together in an example. We start with our UDP client <TT>main</TT> function from <A class="docLink" HREF="0131411551_ch08lev1sec5.html#ch08fig07">Figure 8.7</A> and just change the port number from <TT>SERV_PORT</TT> to 7 (the standard echo server, <A class="docLink" HREF="0131411551_ch02lev1sec12.html#ch02fig18">Figure 2.18</A>).</P>
<P class="docText"><A class="docLink" HREF="#ch22fig06">Figure 22.6</A> is the <TT>dg_cli</TT> function. The only change from <A class="docLink" HREF="0131411551_ch08lev1sec6.html#ch08fig08">Figure 8.8</A> is to replace the calls to <TT>sendto</TT> and <TT>recvfrom</TT> with a call to our new function, <TT>dg_send_recv</TT>.</P>
<P class="docText">Before showing our <TT>dg_send_recv</TT> function and the RTT functions it calls, <A class="docLink" HREF="#ch22fig07">Figure 22.7</A> shows an outline of how we add reliability to a UDP client. All functions beginning with <TT>rtt_</TT> will be shown shortly.</P>

<H5 class="docExampleTitle"><A NAME="ch22fig06"></A>Figure 22.6 <TT>dg_cli</TT> function that calls our <TT>dg_send_recv</TT> function.</H5>
<P class="docText"><span class="docEmphasis">rtt/dg_cli.c</span></P>

<PRE>
 1 #include    "unp.h"

 2 ssize_t Dg_send_recv(int, const void *, size_t, void *, size_t,
 3                      const SA *, socklen_t);

 4 void
 5 dg_cli(FILE *fp, int sockfd, const SA *pservaddr, socklen_t servlen)
 6 {
 7     ssize_t n;
 8     char    sendline[MAXLINE], recvline[MAXLINE + 1];

 9     while (Fgets(sendline, MAXLINE, fp) != NULL) {

10         n = Dg_send_recv(sockfd, sendline, strlen(sendline),
11                          recvline, MAXLINE, pservaddr, servlen);

12         recvline[n] = 0;        /* null terminate */
13         Fputs(recvline, stdout);
14     }
15 }
</PRE>


<H5 class="docExampleTitle"><A NAME="ch22fig07"></A>Figure 22.7 Outline of RTT functions and when they are called.</H5>

<PRE>
static sigjmp_buf jmpbuf;
{
    .  .  .
    <span class="docEmphasis">form request</span>

    signal(SIGALRM, sig_alrm); /* establish signal handler */
    rtt_newpack();             /* initialize rexmt counter to 0 */
sendagain:
    sendto();

    alarm(rtt_start());        /* set alarm for RTO seconds */
    if (sigsetjmp(jmpbuf, 1) != 0) {
        if (rtt_timeout())     /* double RTO, retransmitted enough? */
            <span class="docEmphasis">give up</span>
        goto sendagain;        /* retransmit */
    }
    do {
        recvfrom();
    } while (<span class="docEmphasis">wrong sequence</span>#);

    alarm(0);                  /* turn off alarm */
    rtt_stop();                /* calculate RTT and update estimators */

    <span class="docEmphasis">process reply</span>
    .  .  .
}

void
sig_alrm(int signo)
{
    siglongjmp(jmpbuf, 1);
}
</PRE>

<P class="docText">When a reply is received but the sequence number is not the one expected, we call <TT>recvfrom</TT> again, but we do not retransmit the request and we do not restart the retransmission timer that is running. Notice in the rightmost example in <A class="docLink" HREF="#ch22fig05">Figure 22.5</A> that the final reply from the retransmitted request will be in the socket receive buffer the next time the client sends a new request. That is fine as the client will read this reply, notice that the sequence number is not the one expected, discard the reply, and call <TT>recvfrom</TT> again.</P>
<P class="docText">We call <TT>sigsetjmp</TT> and <TT>siglongjmp</TT> to avoid the race condition with the <TT>SIGALRM</TT> signal we described in <A class="docLink" HREF="0131411551_ch20lev1sec5.html#ch20lev1sec5">Section 20.5</A>.</P>
<P class="docText"><A class="docLink" HREF="#ch22fig08">Figure 22.8</A> shows the first half of our <TT>dg_send_recv</TT> function.</P>
<p class="docText"><span class="docEmphasis"><TT>1–5</TT></span> We include a new header, <TT>unprtt.h</TT>, shown in <A class="docLink" HREF="#ch22fig10">Figure 22.10</A>, which defines the <TT>rtt_info</TT> structure that maintains the RTT information for a client. We define one of these structures and numerous other variables.</p>
<A NAME="ch22lev3sec15"></A>
<H5 class="docSection3Title"> Define <TT>msghdr</TT> structures and <TT>hdr</TT> structure</H5>
<p class="docText"><span class="docEmphasis"><TT>6–10</TT></span> We want to hide the fact from the caller that we prepend a sequence number and a timestamp to each packet. The easiest way to do this is to use <TT>writev</TT>, writing our header (the <TT>hdr</TT> structure), followed by the caller's data, as a single UDP datagram. Recall that the output for <TT>writev</TT> on a datagram socket is a single datagram. This is easier than forcing the caller to allocate room at the front of its buffer for our use and is also faster than copying our header and the caller's data into one buffer (that we would have to allocate) for a single <TT>sendto</TT>. But since we are using UDP and have to specify a destination address, we must use the <TT>iovec</TT> capability of <TT>sendmsg</TT> and <TT>recvmsg</TT>, instead of <TT>sendto</TT> and <TT>recvfrom</TT>. Recall from <A class="docLink" HREF="0131411551_ch14lev1sec5.html#ch14lev1sec5">Section 14.5</A> that some systems have a newer <TT>msghdr</TT> structure with ancillary data, while older systems still have the access rights members at the end of the structure. To avoid complicating the code with <TT>#ifdefs</TT> to handle these differences, we declare two <TT>msghdr</TT> structures as <TT>static</TT>, forcing their initialization to all zero bits by C and then just ignore the unused members at the end of the structures.</p>

<A NAME="ch22lev3sec16"></A>
<H5 class="docSection3Title"> Initialize first time we are called</H5>
<p class="docText"><span class="docEmphasis"><TT>20–24</TT></span> The first time we are called, we call the <TT>rtt_init</TT> function.</p>

<A NAME="ch22lev3sec17"></A>
<H5 class="docSection3Title"> Fill in <TT>msghdr</TT> structures</H5>
<p class="docText"><span class="docEmphasis"><TT>25–41</TT></span> We fill in the two <TT>msghdr</TT> structures that are used for output and input. We increment the sending sequence number for this packet, but do not set the sending timestamp until we send the packet (since it might be retransmitted, and each retransmission needs the current timestamp).</p>
<P class="docText">The second half of the function, along with the <TT>sig_alrm</TT> signal handler, is shown in <A class="docLink" HREF="#ch22fig09">Figure 22.9</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch22fig08"></A>Figure 22.8 <TT>dg_send_recv</TT> function: first half.</H5>

<PRE>
 1 #include    "unprtt.h"
 2 #include    &lt;setjmp.h&gt;

 3 #define RTT_DEBUG

 4 static struct rtt_info rttinfo;
 5 static int rttinit = 0;
 6 static struct msghdr msgsend, msgrecv;  /* assumed init to 0 */
 7 static struct hdr {
 8     uint32_t seq;               /* sequence # */
 9     uint32_t ts;                /* timestamp when sent */
10 } sendhdr, recvhdr;

11 static void sig_alrm(int signo);
12 static sigjmp_buf jmpbuf;

13 ssize_t
14 dg_send_recv(int fd, const void *outbuff, size_t outbytes,
15              void *inbuff, size_t inbytes,
16              const SA *destaddr, socklen_t destlen)
17 {
18     ssize_t n;
19     struct iovec iovsend[2], iovrecv[2];

20     if (rttinit == 0) {
21         rtt_init(&amp;rttinfo);     /* first time we're called */
22         rttinit = 1;
23         rtt_d_flag = 1;
24     }

25     sendhdr.seq++;
26     msgsend.msg_name = destaddr;
27     msgsend.msg_namelen = destlen;
28     msgsend.msg_iov = iovsend;
29     msgsend.msg_iovlen = 2;
30     iovsend[0].iov_base = &amp;sendhdr;
31     iovsend[0].iov_len = sizeof(struct hdr);
32     iovsend[1].iov_base = outbuff;
33     iovsend[1].iov_len = outbytes;

34     msgrecv.msg_name = NULL;
35     msgrecv.msg_namelen = 0;
36     msgrecv.msg_iov = iovrecv;
37     msgrecv.msg_iovlen = 2;
38     iovrecv[0].iov_base = &amp;recvhdr;
39     iovrecv[0].iov_len = sizeof(struct hdr);
40     iovrecv[1].iov_base = inbuff;
41     iovrecv[1].iov_len = inbytes;
</PRE>


<H5 class="docExampleTitle"><A NAME="ch22fig09"></A>Figure 22.9 <TT>dg_send_recv</TT> function:second half.</H5>
<P class="docText"><span class="docEmphasis">rtt/dg_send_recv.c</span></P>

<PRE>
42    Signal(SIGALRM, sig_alrm);
43    rtt_newpack(&amp;rttinfo);      /* initialize for this packet */

44  sendagain:
45    sendhdr.ts = rtt_ts(&amp;rttinfo);
46    Sendmsg(fd, &amp;msgsend, 0);

47    alarm(rtt_start(&amp;rttinfo)); /* calc timeout value &amp; start timer */

48    if (sigsetjmp(jmpbuf, 1) != 0) {
49        if (rtt_timeout(&amp;rttinfo) &lt; 0) {
50            err_msg("dg_send_recv: no response from server, giving up");
51            rttinit = 0;        /* reinit in case we're called again */
52            errno = ETIMEDOUT;
53            return (-1);
54        }
55        goto sendagain;
56    }

57    do {
58        n = Recvmsg(fd, &amp;msgrecv, 0);
59    } while (n &lt; sizeof(struct hdr) || recvhdr.seq ! = sendhdr.seq);

60    alarm(0);                   /* stop SIGALRM timer */
61        /* calculate &amp; store new RTT estimator values */
62    rtt_stop(&amp;rttinfo, rtt_ts(&amp;rttinfo) - recvhdr.ts);

63    return (n - sizeof(struct hdr));    /* return size of received datagram */
64 }

65 static void
66 sig_alrm(int signo)
67 {
68     siglongjmp(jmpbuf, 1);
69 }
</PRE>


<A NAME="ch22lev3sec18"></A>
<H5 class="docSection3Title"> Establish signal handler</H5>
<p class="docText"><span class="docEmphasis"><TT>42–43</TT></span> A signal handler is established for <TT>SIGALRM</TT> and <TT>rtt_newpack</TT> sets the retransmission counter to 0.</p>

<A NAME="ch22lev3sec19"></A>
<H5 class="docSection3Title"> Send datagram</H5>
<p class="docText"><span class="docEmphasis"><TT>45–47</TT></span> The current timestamp is obtained by <TT>rtt_ts</TT> and stored in the <TT>hdr</TT> structure prepended to the user's data. A single UDP datagram is sent by <TT>sendmsg. rtt_start</TT> returns the number of seconds for this timeout and the <TT>SIGALRM</TT> is scheduled by calling <TT>alarm</TT>.</p>

<A NAME="ch22lev3sec20"></A>
<H5 class="docSection3Title"> Establish jump buffer</H5>
<p class="docText"><span class="docEmphasis"><TT>48</TT></span> We establish a jump buffer for our signal handler with <TT>sigsetjmp</TT>. We wait for the next datagram to arrive by calling <TT>recvmsg</TT>. (We discussed the use of <TT>sigsetjmp</TT> and <TT>siglongjmp</TT> along with <TT>SIGALRM</TT> with <A class="docLink" HREF="0131411551_ch20lev1sec5.html#ch20fig09">Figure 20.9</A>.) If the alarm timer expires, <TT>sigsetjmp</TT> returns 1.</p>

<A NAME="ch22lev3sec21"></A>
<H5 class="docSection3Title"> Handle timeout</H5>
<p class="docText"><span class="docEmphasis"><TT>49–55</TT></span> When a timeout occurs, <TT>rtt_timeout</TT> calculates the next <span class="docEmphasis">RTO</span> (the exponential backoff) and returns -1 if we should give up, or 0 if we should retransmit. If we give up, we set <TT>errno</TT> to <TT>ETIMEDOUT</TT> and return to the caller.</p>

<A NAME="ch22lev3sec22"></A>
<H5 class="docSection3Title"> Call <TT>recvmsg</TT>, compare sequence numbers</H5>
<p class="docText"><span class="docEmphasis"><TT>57–59</TT></span> We wait for a datagram to arrive by calling <TT>recvmsg</TT>. When it returns, the datagram's length must be at least the size of our <TT>hdr</TT> structure and its sequence number must equal the sequence number that was sent. If either comparison is false, <TT>recvmsg</TT> is called again.</p>

<A NAME="ch22lev3sec23"></A>
<H5 class="docSection3Title"> Turn off alarm and update RTT estimators</H5>
<p class="docText"><span class="docEmphasis"><TT>60–62</TT></span> When the expected reply is received, the pending <TT>alarm</TT> is turned off and <TT>rtt_stop</TT> updates the RTT estimators. <TT>rtt_ts</TT> returns the current timestamp and the timestamp from the received datagram is subtracted from this, giving the RTT.</p>

<A NAME="ch22lev3sec24"></A>
<H5 class="docSection3Title"> <TT>SIGALRM</TT> handler</H5>
<p class="docText"><span class="docEmphasis"><TT>65–69</TT></span> <TT>siglongjmp</TT> is called, causing the <TT>sigsetjmp</TT> in <TT>dg_send_recv</TT> to return 1.</p>
<P class="docText">We now look at the various RTT functions that were called by <TT>dg_send_recv</TT>. <A class="docLink" HREF="#ch22fig10">Figure 22.10</A> shows the <TT>unprtt.h</TT> header.</P>

<H5 class="docExampleTitle"><A NAME="ch22fig10"></A>Figure 22.10 <TT>unprtt.h</TT> header.</H5>
<P class="docText"><span class="docEmphasis">lib/unprtt.h</span></P>

<PRE>
 1 #ifndef __unp_rtt_h
 2 #define __unp_rtt_h

 3 #include    "unp.h"

 4 struct rtt_info {
 5     float   rtt_rtt;            /* most recent measured RTT, in seconds */
 6     float   rtt_srtt;           /* smoothed RTT estimator, in seconds */
 7     float   rtt_rttvar;         /* smoothed mean deviation, in seconds */
 8     float   rtt_rto;            /* current RTO to use, in seconds */
 9     int     rtt_nrexmt;         /* # times retransmitted: 0, 1, 2, ... */
10     uint32_t rtt_base;          /* # sec since 1/1/1970 at start */
11 };

12 #define RTT_RXTMIN      2       /* min retransmit timeout value, in seconds */
13 #define RTT_RXTMAX     60       /* max retransmit timeout value, in seconds */
14 #define RTT_MAXNREXMT   3       /* max # times to retransmit */

15                 /* function prototypes */
16 void    rtt_debug(struct rtt_info *);
17 void    rtt_init(struct rtt_info *);
18 void    rtt_newpack(struct rtt_info *);
19 int     rtt_start(struct rtt_info *);
20 void    rtt_stop(struct rtt_info *, uint32_t);
21 int     rtt_timeout(struct rtt_info *);
22 uint32_t rtt_ts(struct rtt_info *);

23 extern int rtt_d_flag;          /* can be set to nonzero for addl info */

24 #endif  /* __unp_rtt_h */
</PRE>


<A NAME="ch22lev3sec25"></A>
<H5 class="docSection3Title"> <TT>rtt_info</TT> structure</H5>
<p class="docText"><span class="docEmphasis"><TT>4–11</TT></span> This structure contains the variables necessary to time the packets between a client and server. The first four variables are from the equations given near the beginning of this section.</p>
<p class="docText"><span class="docEmphasis"><TT>12–14</TT></span> These constants define the minimum and maximum retransmission timeouts and the maximum number of times we retransmitted.</p>
<P class="docText"><A class="docLink" HREF="#ch22fig11">Figure 22.11</A> shows a macro and the first two of our RTT functions.</P>

<H5 class="docExampleTitle"><A NAME="ch22fig11"></A>Figure 22.11 <TT>RTT_RTOCALC</TT> macro and <TT>rtt_minmax</TT> and <TT>rtt_init</TT> functions.</H5>
<P class="docText"><span class="docEmphasis">lib/rtt.c</span></P>

<PRE>
 1 #include    "unprtt.h"

 2 int     rtt_d_flag = 0;         /* debug flag; can be set by caller */

 3 /*
 4  * Calculate the RTO value based on current estimators:
 5  *      smoothed RTT plus four times the deviation
 6  */
 7 #define RTT_RTOCALC(ptr) ((ptr)-&gt;rtt_srtt + (4.0 * (ptr)-&gt;rtt_rttvar))

 8 static float
 9 rtt_minmax(float rto)
10 {
11     if (rto &lt; RTT_RXTMIN)
12         rto = RTT_RXTMIN;
13     else if (rto &gt; RTT_RXTMAX)
14         rto = RTT_RXTMAX;
15     return (rto);
16 }

17 void
18 rtt_init(struct rtt_info *ptr)
19 {
20     struct timeval tv;

21     Gettimeofday(&amp;tv, NULL);
22     ptr-&gt;rtt_base = tv.tv_sec;   /* # sec since 1/1/1970 at start */

23     ptr-&gt;rtt_rtt = 0;
24     ptr-&gt;rtt_srtt = 0;
25     ptr-&gt;rtt_rttvar = 0.75;
26     ptr-&gt;rtt_rto = rtt_minmax(RTT_RTOCALC(ptr));
27     /* first RTO at (srtt + (4 * rttvar)) = 3 seconds */
28 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>3–7</TT></span> The <TT>RTT_RTOCALC</TT> macro calculates the <span class="docEmphasis">RTO</span> as the RTT estimator plus four times the mean deviation estimator.</p>
<p class="docText"><span class="docEmphasis"><TT>8–16</TT></span> <TT>rtt_minmax</TT> makes certain that the <span class="docEmphasis">RTO</span> is between the upper and lower limits in the <TT>unprtt.h</TT> header.</p>
<p class="docText"><span class="docEmphasis"><TT>17–28</TT></span> <TT>rtt_init</TT> is called by <TT>dg_send_recv</TT> the first time any packet is sent. <TT>gettimeofday</TT> returns the current time and date in the same <TT>timeval</TT> structure that we saw with <TT>select</TT> (<A class="docLink" HREF="0131411551_ch06lev1sec3.html#ch06lev1sec3">Section 6.3</A>). We save only the current number of seconds since the Unix Epoch, which is 00:00:00 January 1, 1970, UTC. The measured RTT is set to 0 and the RTT and mean deviation estimators are set to 0 and 0.75, respectively, giving an initial <span class="docEmphasis">RTO</span> of 3 seconds.</p>
<P class="docText"><A class="docLink" HREF="#ch22fig12">Figure 22.12</A> shows the next three RTT functions.</P>

<H5 class="docExampleTitle"><A NAME="ch22fig12"></A>Figure 22.12 <TT>rtt_ts</TT>, <TT>rtt_newpack</TT>, and <TT>rtt_start</TT> functions.</H5>
<P class="docText"><span class="docEmphasis">lib/rtt.c</span></P>

<PRE>
34 uint 32_t
35 rtt_ts(struct rtt_info *ptr)
36 {
37     uint32_t ts;
38     struct timeval tv;

39     Gettimeofday(&amp;tv, NULL);
40     ts = ((tv.tv_sec - ptr-&gt;rtt_base) * 1000) + (tv. tv_usec / 1000);
41     return (ts);
42 }

43 void
44 rtt_newpack(struct rtt_info *ptr)
45 {
46     ptr-&gt;rtt_nrexmt = 0;
47 }

48 int
49 rtt_start(struct rtt_info *ptr)
50 {
51     return ((int) (ptr-&gt;rtt_rto + 0.5));    /* round float to int */
52         /* return value can be used as: alarm(rtt_start(&amp;foo)) */
53 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>34–42</TT></span> <TT>rtt_ts</TT> returns the current timestamp for the caller to store as an unsigned 32-bit integer in the datagram being sent. We obtain the current time and date from <TT>gettimeofday</TT> and then subtract the number of seconds when <TT>rtt_init</TT> was called (the value saved in <TT>rtt_base</TT>). We convert this to milliseconds and also convert the microsecond value returned by <TT>gettimeofday</TT> into milliseconds. The timestamp is then the sum of these two values in milliseconds.</p>
<P class="docText">The difference between two calls to <TT>rtt_ts</TT> is the number of milliseconds between the two calls. But, we store the millisecond timestamps in an unsigned 32-bit integer instead of a <TT>timeval</TT> structure.</P>
<p class="docText"><span class="docEmphasis"><TT>43–47</TT></span> <TT>rtt_newpack</TT> just sets the retransmission counter to 0. This function should be called whenever a new packet is sent for the first time.</p>
<p class="docText"><span class="docEmphasis"><TT>48–53</TT></span> <TT>rtt_start</TT> returns the current <span class="docEmphasis">RTO</span> in seconds. The return value can then be used as the argument to <TT>alarm</TT>.</p>
<P class="docText"><TT>rtt_stop</TT>, shown in <A class="docLink" HREF="#ch22fig13">Figure 22.13</A>, is called after a reply is received to update the RTT estimators and calculate the new <span class="docEmphasis">RTO</span>.</P>

<H5 class="docExampleTitle"><A NAME="ch22fig13"></A>Figure 22.13 <TT>rtt_stop</TT> function: updates RTT estimators and calculates new <span class="docEmphasis">RTO</span>.</H5>
<P class="docText"><span class="docEmphasis">lib/rtt.c</span></P>

<PRE>
62 void
63 rtt_stop(struct rtt_info *ptr, uint32_t ms)
64 {
65     double  delta;

66     ptr-&gt;rtt_rtt = ms / 1000.0; /* measured RTT in seconds */

67     /*
68      * Update our estimators of RTT and mean deviation of RTT.
69      * See Jacobson's SIGCOMM '88 paper, Appendix A, for the details.
70      * We use floating point here for simplicity.
71      */

72     delta = ptr-&gt;rtt_rtt - ptr-&gt;rtt_srtt;
73     ptr-&gt;rtt_srtt += delta / 8; /* g = 1/8 */

74     if (delta &lt; 0.0)
75         delta = -delta;         /* |delta| */

76     ptr-&gt;rtt_rttvar += (delta - ptr-&gt;rtt_rttvar) / 4; /* h = 1/4 */

77     ptr-&gt;rtt_rto = rtt_minmax(RTT_RTOCALC(ptr));
78 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>62–78</TT></span> The second argument is the measured RTT, obtained by the caller by subtracting the received timestamp in the reply from the current timestamp (<TT>rtt_ts</TT>). The equations at the beginning of this section are then applied, storing new values for <TT>rtt_srtt</TT>, <TT>rtt_rttvar</TT>, and <TT>rtt_rto</TT>.</p>
<P class="docText">The final function, <TT>rtt_timeout</TT>, is shown in <A class="docLink" HREF="#ch22fig14">Figure 22.14</A>. This function is called when the retransmission timer expires.</P>

<H5 class="docExampleTitle"><A NAME="ch22fig14"></A>Figure 22.14 <TT>rtt_timeout</TT> function: applies exponential backoff.</H5>
<P class="docText"><span class="docEmphasis">lib/rtt.c</span></P>

<PRE>
83 int
84 rtt_timeout(struct rtt_info *ptr)
85 {
86     ptr-&gt;rtt_rto *= 2;          /* next RTO */

87     if (++ptr-&gt;rtt_nrexmt &gt; RTT_MAXNREXMT)
88         return (-1);            /* time to give up for this packet */
89     return (0);
90 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>86</TT></span> The current <span class="docEmphasis">RTO</span> is doubled: This is the exponential backoff.</p>
<p class="docText"><span class="docEmphasis"><TT>87–89</TT></span> If we have reached the maximum number of retransmissions, –1 is returned to tell the caller to give up; otherwise, 0 is returned.</p>
<P class="docText">As an example, our client was run twice to two different echo servers across the Internet in the morning on a weekday. Five hundred lines were sent to each server. Eight packets were lost to the first server and 16 packets were lost to the second server. Of the 16 lost to the second server, one packet was lost twice in a row: that is, the packet had to be retransmitted two times before a reply was received. All other lost packets were handled with a single retransmission. We could verify that these packets were really lost by printing the sequence number of each received packet. If a packet is just delayed and not lost, after the retransmission, two replies will be received by the client: one corresponding to the original transmission that was delayed and one corresponding to the retransmission. Notice we are unable to tell when we retransmit whether it was the client's request or the server's reply that was discarded.</P>
<BLOCKQUOTE><P><P class="docList">For the first edition of this book, the author wrote a UDP server that randomly discarded packets to test this client. That is no longer needed; all we have to do is run the client to a server across the Internet and we are almost guaranteed of some packet loss!</P></P></BLOCKQUOTE>



<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch22lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch22lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
