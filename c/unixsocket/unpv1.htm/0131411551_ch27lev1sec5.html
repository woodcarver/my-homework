<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="27.5 IPv6 Hop-by-Hop Options and Destination Options"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch27lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch27lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch27lev1sec5"></A>
<H3 class="docSection1Title">27.5 IPv6 Hop-by-Hop Options and Destination Options</H3>
<P class="docText">The hop-by-hop and destination options have a similar format, shown in <A class="docLink" HREF="#ch27fig07">Figure 27.7</A>. The 8-bit <span class="docEmphasis">next header</span> field identifies the next header that follows this extension header. The 8-bit <span class="docEmphasis">header extension length</span> is the length of this extension header, in units of 8 bytes, but not including the first 8 bytes. For example, if this extension header occupies 8 bytes, then its header extension length is 0; if this extension header occupies 16 bytes, then its header extension length is 1, and so on. These two headers are padded to be a multiple of 8 bytes with either the <TT>pad1</TT> option or the <TT>padN</TT> option, which will be described shortly.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch27fig07"></A>Figure 27.7. Format of hop-by-hop and destination options.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="464" HEIGHT="170" src="FILES/27fig07.gif" ALT="graphics/27fig07.gif"></p>

</CENTER>
<P class="docText">The hop-by-hop options header and destination options header each hold any number of individual options, which have the format shown in <A class="docLink" HREF="#ch27fig08">Figure 27.8</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch27fig08"></A>Figure 27.8. Format of individual hop-by-hop and destination options.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="276" HEIGHT="57" src="FILES/27fig08.gif" ALT="graphics/27fig08.gif"></p>

</CENTER>
<P class="docText">This is called <span class="docEmphasis">TLV coding</span> because each option appears with its type, length, and value. The 8-bit <span class="docEmphasis">type</span> field identifies the option type. Additionally, the two high-order bits specify what an IPv6 node does with this option if it does not understand the option:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>00</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Skip over this option and continue processing the header.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>01</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Discard the packet.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>10</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Discard the packet and send an ICMP parameter problem type 2 error (<A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig16">Figure A.16</A>) to the sender, regardless of whether or not the packet's destination is a multicast address.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>11</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Discard the packet and send an ICMP parameter problem type 2 error (<A class="docLink" HREF="0131411551_app01lev1sec6.html#app01fig16">Figure A.16</A>) to the sender. This error is sent only if the packet's destination is not a multicast address.</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">The next high-order bit specifies whether or not the option data changes en route:</P>
<P><TABLE CELLSPACING="0" FRAME="void" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="2"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>0</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">The option data does not change en route.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>1</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">The option data may change en route.</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">The low-order 5 bits then specify the option. Note that all 8 bits make up the option code; the low-order 5 bits do not by themselves identify the option. However, option value assignments are made to keep the low-order 5 bits unique for as long as possible.</P>
<P class="docText">The 8-bit <span class="docEmphasis">length</span> field specifies the length of the option data in bytes. The type field and this length field are not included in this length.</P>
<P class="docText">The two pad options are defined in RFC 2460 [Deering and Hinden 1998] and can be used in either the hop-by-hop options header or in the destination options header. The <span class="docEmphasis">jumbo payload length</span>, a hop-by-hop option, is defined in RFC 2675 [Borman, Deering, and Hinden 1999], and it is generated when needed and processed when received entirely by the kernel. <span class="docEmphasis">Router alert</span>, a hop-by-hop option, is described for IPv6 in RFC 2711 [Partridge and Jackson 1999] and is similar to the IPv4 router alert. We show these in <A class="docLink" HREF="#ch27fig09">Figure 27.9</A>. Other options are also defined, for instance, for Mobile-IPv6, but we do not show them here.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch27fig09"></A>Figure 27.9. IPv6 hop-by-hop options.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="449" HEIGHT="323" src="FILES/27fig09.gif" ALT="graphics/27fig09.gif"></p>

</CENTER>
<P class="docText">The <TT>pad1</TT> byte is the only option without a length and value. It provides 1 byte of padding. The <TT>pad</TT><span class="docEmphasis">N</span> option is used when 2 or more bytes of padding are required. For 2 bytes of padding, the length of this option would be 0 and the option would consist of just the type field and the length field. For 3 bytes of padding, the length would be 1, and 1 byte of 0 would follow this length. The jumbo payload length option provides a datagram length of 32 bits and is used when the 16-bit payload length field in <A class="docLink" HREF="0131411551_app01lev1sec3.html#app01fig02">Figure A.2</A> is inadequate. The router alert option indicates that this packet should be intercepted by certain routers along the path; the value in the router alert option indicates what routers should be interested.</P>
<P class="docText">We show the padding options because each hop-by-hop and destination option also has an associated <span class="docEmphasis">alignment requirement</span>, written as <span class="docEmphasis">x</span>n + <span class="docEmphasis">y</span>. This means that the option must appear at an integer multiple of <span class="docEmphasis">x</span> bytes from the start of the header, plus <span class="docEmphasis">y</span> bytes. For example, the alignment requirement of the jumbo payload option is 4n + 2, and this is to force the 4-byte option value (the jumbo payload length) to be on a 4-byte boundary. The reason why the <span class="docEmphasis">y</span> value is 2 for this option is because of the 2 bytes that appear at the beginning of each hop-by-hop and destination options header (<A class="docLink" HREF="#ch27fig08">Figure 27.8</A>). The alignment requirement of the router alert option is 2n + 0, to force the 2-byte option value to be on a 2-byte boundary.</P>
<P class="docText">The hop-by-hop and destination options are normally specified as ancillary data with <TT>sendmsg</TT> and returned as ancillary data by <TT>recvmsg</TT>. Nothing special needs to be done by the application to send either or both of these options; just specify them in a call to <TT>sendmsg</TT>. To receive these options, the corresponding socket option must be enabled: <TT>IPV6_RECVHOPOPTS</TT> for the hop-by-hop options and <TT>IPV6_RECVDSTOPTS</TT> for the destination options. For example, to enable both options to be returned,</P>
<pre>

</pre><pre>
const int on = 1;

setsockopt(sockfd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &amp;on, sizeof(on));
setsockopt(sockfd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &amp;on, sizeof(on));
</pre><pre>
</pre>
<P class="docText"><A class="docLink" HREF="#ch27fig10">Figure 27.10</A> shows the format of the ancillary data objects used to send and receive the hop-by-hop and destination options.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch27fig10"></A>Figure 27.10. Ancillary data objects for hop-by-hop and destination options.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="141" src="FILES/27fig10.gif" ALT="graphics/27fig10.gif"></p>

</CENTER>
<P class="docText">The actual contents of the IPv6 option header is passed between the user and the kernel as the <TT>cmsg_data</TT> portion of these objects. To reduce code duplication, seven functions are defined to create and process these data sections. The following four functions build an option to send:</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;netinet/in.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_opt_init(void *</TT><span class="docEmphasis">extbuf</span><TT>, socklen_t</TT> <span class="docEmphasis">extlen</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: number of bytes required to hold empty extension header, -1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_opt_append(void *</TT><span class="docEmphasis">extbuf</span><TT>, socklen_t</TT> <span class="docEmphasis">extlen</span><TT>, int</TT> <span class="docEmphasis">offset</span><TT>, uint8_t</TT> <span class="docEmphasis">type</span><TT>, socklen_t</TT> <span class="docEmphasis">len</span><TT>, uint_t</TT> <span class="docEmphasis">align</span><TT>, void **</TT><span class="docEmphasis">databufp</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: updated length of overall extension header after adding option, -1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_opt_finish(void *</TT><span class="docEmphasis">extbuf</span><TT>, socklen_t</TT> <span class="docEmphasis">extlen</span>, <TT>int</TT> <span class="docEmphasis">offset</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: updated length of finished extension header, –1 on error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_opt_set_val(void *</TT><span class="docEmphasis">databuf</span><TT>, int</TT> <span class="docEmphasis">offset</span>, <TT>const void *</TT><span class="docEmphasis">val</span>, <TT>socklen_t</TT> <span class="docEmphasis">vallen</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: new offset inside <span class="docEmphasis">databuf</span></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><TT>inet6_opt_init</TT> returns the number of bytes required to hold an empty extension header. If the <span class="docEmphasis">extbuf</span> argument is not <TT>NULL</TT>, it initializes the extension header. It fails and returns -1 if the <span class="docEmphasis">extbuf</span> argument is supplied but the <span class="docEmphasis">extlen</span> argument is not a multiple of 8. (All IPv6 hop-by-hop and destination options headers must be multiples of 8 bytes.)</P>
<P class="docText"><TT>inet6_opt_append</TT> returns the updated total length of the extension header after appending the specified option. If the <span class="docEmphasis">extbuf</span> argument is not <TT>NULL</TT>, it also initializes the option and inserts any necessary padding. It fails and returns -1 if the new option does not fit in the supplied buffer. The <span class="docEmphasis">offset</span> argument is the current running total length, and must be the return value from a previous call to <TT>inet6_opt_init</TT> or <TT>inet6_opt_append</TT>. The <span class="docEmphasis">type</span> and <span class="docEmphasis">len</span> arguments are the type and length of the option, and are copied directly into the option header. The <span class="docEmphasis">align</span> argument specifies the alignment requirement, that is, <span class="docEmphasis">x</span> from the function <span class="docEmphasis">x</span>n + <span class="docEmphasis">y</span>. The value of <span class="docEmphasis">y</span> is derived from <span class="docEmphasis">align</span> and <span class="docEmphasis">len</span>, so it does not need to be explicitly specified. The <span class="docEmphasis">databufp</span> argument is the address to a pointer that will be filled in with the location of the option value; the caller can then copy the option value into this location using the <TT>inet6_opt_set_val</TT> function or any other method.</P>
<P class="docText"><TT>inet6_opt_finish</TT> is called to complete an extension header, adding any needed padding to make the overall header a multiple of 8 bytes. As before, if the <span class="docEmphasis">extbuf</span> argument is non-<TT>NULL</TT>, the padding is actually inserted into the buffer; otherwise, the function simply computes the updated length. As with <TT>inet6_opt_append</TT>, the <span class="docEmphasis">offset</span> argument is the current running total length, the return value from a previous <TT>inet6_opt_init</TT> or <TT>inet6_opt_append</TT>. <TT>inet6_opt_finish</TT> returns the total length of the completed header, or -1 if the required padding will not fit in the supplied buffer.</P>
<P class="docText"><TT>inet6_opt_set_val</TT> copies an option value into the data buffer returned by <TT>inet6_opt_append</TT>. The <span class="docEmphasis">databuf</span> argument is the pointer returned from <TT>inet6_opt_append</TT>. <span class="docEmphasis">offset</span> is a running length within this option; it must be initialized to 0 for each option and then will be the return value from the previous <TT>inet6_opt_set_val</TT> as the option is built up. The <span class="docEmphasis">val</span> and <span class="docEmphasis">vallen</span> arguments specify the value to copy into the option value buffer.</P>
<P class="docText">The expected use of these functions is to make two passes through the list of options you intend to insert: the first to calculate the desired length, and the second to actually build the option into an appropriately sized buffer. During the first pass, we call <TT>inet6_opt_init</TT>, <TT>inet6_opt_append</TT> once for each option we will append, and <TT>inet6_opt_finish</TT>, passing NULL and 0 for the <span class="docEmphasis">extbuf</span> and <span class="docEmphasis">extlen</span> arguments, respectively. We then dynamically allocate the option buffer using the size returned by <TT>inet6_opt_finish</TT>, and we will pass this buffer as the <span class="docEmphasis">extbuf</span> argument during the second pass. During the second pass, we call <TT>inet6_opt_init</TT> and <TT>inet6_opt_append</TT>, either copying the data manually or using <TT>inet6_opt_set_val</TT> for each option value. Finally, we call <TT>inet6_opt_finish</TT>. Alternately, we can pre-allocate a buffer that should be large enough for our desired options and skip the first pass; however, this is vulnerable to failure if a change in the desired options would over-run the pre-allocated buffer.</P>
<P class="docText">The remaining three functions process a received option:</P>
<P><TABLE CELLSPACING="0" BORDER="1" RULES="none" CELLPADDING="5" WIDTH="100%"><COLGROUP align="left" span="1"><THEAD></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>#include &lt;netinet/in.h&gt;</TT></P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_opt_next(const void *</TT><span class="docEmphasis">extbuf</span><TT>, socklen_t</TT> <span class="docEmphasis">extlen</span><TT>, int</TT> <span class="docEmphasis">offset</span><TT>, uint8_t *</TT><span class="docEmphasis">typep</span><TT>, socklen_t *</TT><span class="docEmphasis">lenp</span><TT>, void **</TT><span class="docEmphasis">databufp</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: offset of next option, -1 on end of options or error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_opt_find(const void *</TT><span class="docEmphasis">extbuf</span><TT>, socklen_t</TT> <span class="docEmphasis">extlen</span><TT>, int</TT> <span class="docEmphasis">offset</span><TT>, uint8_t</TT> <span class="docEmphasis">type</span><TT>, socklen_t *</TT><span class="docEmphasis">lenp</span><TT>, void **</TT><span class="docEmphasis">databufp</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: offset of next option, -1 on end of options or error</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>int inet6_opt_get_val(const void *</TT><span class="docEmphasis">databuf</span><TT>, int</TT> <span class="docEmphasis">offset</span><TT>, void *</TT><span class="docEmphasis">val</span>, <TT>socklen_t</TT> <span class="docEmphasis">vallen</span><TT>) ;</TT></P></TD></TR><TR><TD class="docTableCell" align="right" valign="top"><P class="docText">Returns: new offset inside <span class="docEmphasis">databuf</span></P></TD></TR></COLGROUP></TABLE></P>
<P class="docText"><TT>inet6_opt_next</TT> processes the next option in a buffer. <span class="docEmphasis">extbuf</span> and <span class="docEmphasis">extlen</span> specify the buffer containing the header. As with <TT>inet6_opt_append</TT>, <span class="docEmphasis">offset</span> is a running offset into the buffer. It is 0 for the first call to <TT>inet6_opt_next</TT>, and then it is the return value from the previous call for future calls. <span class="docEmphasis">typep, lenp</span>, and <span class="docEmphasis">databufp</span> return the type, length, and value of the option, respectively. <TT>inet6_opt_next</TT> returns -1 if the header is malformed or if it has reached the end of the buffer.</P>
<P class="docText"><TT>inet6_opt_find</TT> is similar to the previous function, but it lets the caller specify the option type to search for (the <span class="docEmphasis">type</span> argument) instead of always returning the next option.</P>
<P class="docText"><TT>inet6_opt_get_val</TT> is used to extract values from an option, using the <span class="docEmphasis">databuf</span> pointer returned by a previous <TT>inet6_opt_next</TT> or <TT>inet6_opt_find</TT> call. As with <TT>inet6_opt_set_val</TT>, the <span class="docEmphasis">offset</span> argument must start at 0 for each option, then must be the return value of a previous call to <TT>inet6_opt_get_val</TT>.</P>

<a href="0131411551_23961534.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch27lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch27lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
