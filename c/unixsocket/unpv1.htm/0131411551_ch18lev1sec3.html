<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="18.3 Reading and Writing"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131411551_ch18lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131411551_ch18lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch18lev1sec3"></A>
<H3 class="docSection1Title">18.3 Reading and Writing</H3>
<P class="docText">After a process creates a routing socket, it can send commands to the kernel by writing to the socket and read information from the kernel by reading from the socket. There are 12 different routing commands, 5 of which can be issued by the process. These commands are defined by including the <TT>&lt;net/route.h&gt;</TT> header and are shown in <A class="docLink" HREF="#ch18fig02">Figure 18.2</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch18fig02"></A>Figure 18.2. Types of messages exchanged across a routing socket.</H5>

<p class="docText">
<IMG BORDER="0" id="129022115118" WIDTH="500" HEIGHT="205" src="FILES/18fig02.gif" ALT="graphics/18fig02.gif"></p>

</CENTER>
<P class="docText">Five different structures are exchanged across a routing socket, as shown in the final column of this figure: <TT>rt_msghdr</TT>, <TT>if_announcemsghdr</TT>, <TT>if_msghdr</TT>, <TT>ifa_msghdr</TT>, and <TT>ifma_msghdr</TT>, which we show in <A class="docLink" HREF="#ch18fig03">Figure 18.3</A>.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig03"></A>Figure 18.3 The five structures returned with routing messages.</H5>

<PRE>
struct rt_msghdr {    /* from &lt;net/route.h&gt; */
  u_short  rtm_msglen;   /* to skip over non-understood messages */
  u_char   rtm_version;  /* future binary compatibility */
  u_char   rtm_type;     /* message type */

  u_short  rtm_index;    /* index for associated ifp */
  int      rtm_flags;    /* flags, incl. kern &amp; message, e.g., DONE */
  int      rtm_addrs;    /* bitmask identifying sockaddrs in msg */
  pid_t    rtm_pid;      /* identify sender */
  int      rtm_seq;      /* for sender to identify action */
  int      rtm_errno;    /* why failed */
  int      rtm_use;      /* from rtentry */
  u_long   rtm_inits;    /* which metrics we are initializing */
  struct rt_metrics  rtm_rmx;  /* metrics themselves */
};
struct if_msghdr {    /* from &lt;net/if.h&gt; */
  u_short  ifm_msglen;   /* to skip over non-understood messages */
  u_char   ifm_version;  /* future binary compatibility */
  u_char   ifm_type;     /* message type */

  int      ifm_addrs;    /* like rtm_addrs */
  int      ifm_flags;    /* value of if_flags */
  u_short  ifm_index;    /* index for associated ifp */
  struct if_data  ifm_data;/* statistics and other data about if */
};
struct ifa_msghdr {   /* from &lt;net/if.h&gt; */
  u_short  ifam_msglen;   /* to skip over non-understood messages */
  u_char   ifam_version;  /* future binary compatibility */
  u_char   ifam_type;     /* message type */

  int      ifam_addrs;    /* like rtm_addrs */
  int      ifam_flags;    /* value of ifa_flags */
  u_short  ifam_index;    /* index for associated ifp */
  int      ifam_metric;   /* value of ifa_metric */
};
struct ifma_msghdr {  /* from &lt;net/if.h&gt; */
  u_short ifmam_msglen;   /* to skip over non-understood messages */
  u_char  ifmam_version;  /* future binary compatibility */
  u_char  ifmam_type;     /* message type */

  int     ifmam_addrs;    /* like rtm_addrs */
  int     ifmam_flags;    /* value of ifa_flags */
  u_short ifmam_index;    /* index for associated ifp */
};
struct if_announcemsghdr {  /* from &lt;net/if.h&gt; */
  u_short ifan_msglen;    /* to skip over non-understood messages */
  u_char  ifan_version;   /* future binary compatibility */
  u_char  ifan_type;      /* message type */

  u_short ifan_index;     /* index for associated ifp */
  char    ifan_name[IFNAMSIZ]; /* if name, e.g. "en0" */
  u_short ifan_what;      /* what type of announcement */
};
</PRE>

<P class="docText">The first three members of each structure are the same: length, version, and type of message. The type is one of the constants from the first column in <A class="docLink" HREF="#ch18fig02">Figure 18.2</A>. The length member allows an application to skip over message types it does not understand.</P>
<P class="docText">The members <TT>rtm_addrs</TT>, <TT>ifm_addrs</TT>, <TT>ifam_addrs</TT>, and <TT>ifmam_addrs</TT> are bitmasks that specify which of eight possible socket address structures follow the message. <A class="docLink" HREF="#ch18fig04">Figure 18.4</A> shows the constants and values for each bitmask, which are defined by including the <TT>&lt;net/route.h&gt;</TT> header.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch18fig04"></A>Figure 18.4. Constants used to refer to socket address structures in routing messages.</H5>

<p class="docText">
<IMG BORDER="0" id="129022115118" WIDTH="500" HEIGHT="163" src="FILES/18fig04.gif" ALT="graphics/18fig04.gif"></p>

</CENTER>
<P class="docText">When multiple socket address structures are present, they are always in the order shown in the table.</P>
<A NAME="ch18lev2sec1"></A>
<H4 class="docSection2Title"> Example: Fetch and Print a Routing Table Entry</H4>
<P class="docText">We now show an example using routing sockets. Our program takes a command-line argument consisting of an IPv4 dotted-decimal address and sends an <TT>RTM_GET</TT> message to the kernel for this address. The kernel looks up the address in its IPv4 routing table and returns an <TT>RTM_GET</TT> message with information about the routing table entry. For example, if we execute</P>
<pre>

</pre><pre>
freebsd % <span class="docEmphStrong">getrt 206.168.112.219</span>
dest: 0.0.0.0
gateway: 12.106.32.1
netmask: 0.0.0.0
</pre><pre>
</pre>
<P class="docText">on our host <TT>freebsd</TT>, we see that this destination address uses the default route (which is stored in the routing table with a destination IP address of 0.0.0.0 and a mask of 0.0.0.0). The next-hop router is this system's gateway to the Internet. If we execute</P>
<pre>

</pre><pre>
freebsd % <span class="docEmphStrong">getrt 192.168.42.0</span>
dest: 192.168.42.0
gateway: AF_LINK, index=2
netmask: 255.255.255.0
</pre><pre>
</pre>
<P class="docText">specifying the secondary Ethernet as the destination, the destination is the network itself. The gateway is now the outgoing interface, returned as a <TT>sockaddr_dl</TT> structure with an interface index of 2.</P>
<P class="docText">Before showing the source code, we show what we write to the routing socket in <A class="docLink" HREF="#ch18fig05">Figure 18.5</A> along with what is returned by the kernel.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch18fig05"></A>Figure 18.5. Data exchanged with kernel across routing socket for <TT>RTM_GET</TT> command.</H5>

<p class="docText">
<IMG BORDER="0" id="129022115118" WIDTH="494" HEIGHT="455" src="FILES/18fig05.gif" ALT="graphics/18fig05.gif"></p>

</CENTER>
<P class="docText">We build a buffer containing an <TT>rt_msghdr</TT> structure, followed by a socket address structure containing the destination address for the kernel to look up. The <TT>rtm_type</TT> is <TT>RTM_GET</TT> and the <TT>rtm_addrs</TT> is <TT>RTA_DST</TT> (recall <A class="docLink" HREF="#ch18fig04">Figure 18.4</A>), indicating that the only socket address structure following the <TT>rt_msghdr</TT> structure is one containing the destination address. This command can be used with any protocol family (that provides a routing table), because the family of the address to look up is contained in the socket address structure.</P>
<P class="docText">After sending the message to the kernel, we <TT>read</TT> back the reply, and it has the format shown at the right of <A class="docLink" HREF="#ch18fig05">Figure 18.5</A>: an <TT>rt_msghdr</TT> structure followed by up to four socket address structures. Which of the four socket address structures gets returned depends on the routing table entry; we are told which of the four by the value in the <TT>rtm_addrs</TT> member of the returned <TT>rt_msghdr</TT> structure. The family of each socket address structure is contained in the <TT>sa_family</TT> member, and as we saw in our examples earlier, one time the returned gateway was an IPv4 socket address structure and the next time it was a datalink socket address structure.</P>
<P class="docText"><A class="docLink" HREF="#ch18fig06">Figure 18.6</A> shows the first part of our program.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig06"></A>Figure 18.6 First half of program to issue <TT>RTM_GET</TT> command on routing socket.</H5>
<P class="docText"><span class="docEmphasis">route/getrt.c</span></P>

<PRE>
 1 #include     "unproute.h"

 2 #define BUFLEN   (sizeof(struct rt_msghdr) + 512)
 3                      /* sizeof(struct sockaddr_in6) * 8 = 192 */
 4 #define SEQ      9999

 5 int
 6 main(int argc, char **argv)
 7 {
 8     int     sockfd;
 9     char   *buf;
10     pid_t   pid;
11     ssize_t n;
12     struct rt_msghdr *rtm;
13     struct sockaddr *sa, *rti_info[RTAX_MAX];
14     struct sockaddr_in *sin;

15     if (argc != 2)
16         err_quit("usage: getrt &lt;IPaddress&gt;");

17     sockfd = Socket(AF_ROUTE, SOCK_RAW, 0); /* need superuser privileges */

18     buf = Calloc(1, BUFLEN);     /* and initialized to 0 */

19     rtm = (struct rt_msghdr *) buf;
20     rtm-&gt;rtm_msglen = sizeof(struct rt_msghdr) + sizeof(struct sockaddr_in);
21     rtm-&gt;rtm_version = RTM_VERSION;
22     rtm-&gt;rtm_type = RTM_GET;
23     rtm-&gt;rtm_addrs = RTA_DST;
24     rtm-&gt;rtm_pid = pid = getpid();
25     rtm-&gt;rtm_seq = SEQ;

26     sin = (struct sockaddr_in *) (rtm + 1);
27     sin-&gt;sin_len = sizeof(struct sockaddr_in);
28     sin-&gt;sin_family = AF_INET;
29     Inet_pton(AF_INET, argv[1], &amp;sin-&gt;sin_addr);

30     Write(sockfd, rtm, rtm-&gt;rtm_msglen);

31     do {
32         n = Read(sockfd, rtm, BUFLEN);
33     } while (rtm-&gt;rtm_type != RTM_GET || rtm-&gt;rtm_seq != SEQ ||
34              rtm-&gt;rtm_pid != pid);
</PRE>

<p class="docText"><span class="docEmphasis"><TT>1–3</TT></span> Our <TT>unproute.h</TT> header includes some files that are needed and then includes our <TT>unp.h</TT> file. The constant <TT>BUFLEN</TT> is the size of the buffer that we allocate to hold our message to the kernel, along with the kernel's reply. We need room for one <TT>rt_msghdr</TT> structure and possibly eight socket address structures (the maximum number that is ever returned on a routing socket). Since an IPv6 socket address structure is 28 bytes in size, the value of 512 is more than adequate.</p>
<A NAME="ch18lev3sec1"></A>
<H5 class="docSection3Title"> Create routing socket</H5>
<p class="docText"><span class="docEmphasis"><TT>17</TT></span> We create a raw socket in the <TT>AF_ROUTE</TT> domain, and as we said earlier, this may require superuser privileges. A buffer is allocated and initialized to 0.</p>

<A NAME="ch18lev3sec2"></A>
<H5 class="docSection3Title"> Fill in <TT>rt_msghdr</TT> structure</H5>
<p class="docText"><span class="docEmphasis"><TT>18–25</TT></span> We fill in the structure with our request. We store our process ID and a sequence number of our choosing in the structure. We will compare these values in the responses that we read, looking for the correct reply.</p>

<A NAME="ch18lev3sec3"></A>
<H5 class="docSection3Title"> Fill in Internet socket address structure with destination</H5>
<p class="docText"><span class="docEmphasis"><TT>26–29</TT></span> Following the <TT>rt_msghdr</TT> structure, we build a <TT>sockaddr_in</TT> structure containing the destination IPv4 address for the kernel to look up in its routing table. All we set are the address length, the address family, and the address.</p>

<A NAME="ch18lev3sec4"></A>
<H5 class="docSection3Title"> <TT>write</TT> message to kernel and <TT>read</TT> reply</H5>
<p class="docText"><span class="docEmphasis"><TT>30–34</TT></span> We <TT>write</TT> the message to the kernel and <TT>read</TT> back the reply. Since other processes may have routing sockets open, and since the kernel passes a copy of all routing messages to all routing sockets, we must check the message type, sequence number, and process ID to verify that the message received is the one we are waiting for.</p>
<P class="docText">The last half of this program is shown in <A class="docLink" HREF="#ch18fig07">Figure 18.7</A>. This half processes the reply.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig07"></A>Figure 18.7 Last half of program to issue <TT>RTM_GET</TT> command on routing socket.</H5>
<P class="docText"><span class="docEmphasis">route/getrt.c</span></P>

<PRE>
35     rtm = (struct rt_msghdr *) buf;
36     sa = (struct sockaddr *) (rtm + 1);
37     get_rtaddrs(rtm-&gt;rtm_addrs, sa, rti_info);
38     if ( (sa = rti_info[RTAX_DST]) != NULL)
39         printf("dest: %s\n", Sock_ntop_host(sa, sa-&gt;sa_len));

40     if ( (sa = rti_info[RTAX_GATEWAY]) != NULL)
41         printf("gateway: %s\n", Sock_ntop_host(sa, sa-&gt;sa_len));

42     if ( (sa = rti_info[RTAX_NETMASK]) != NULL)
43         printf("netmask: %s\n", Sock_masktop(sa, sa-&gt;sa_len));

44     if ( (sa = rti_info[RTAX_GENMASK]) != NULL)
45         printf("genmask: %s\n", Sock_masktop(sa, sa-&gt;sa_len));

46     exit(0);
47 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>35–36</TT></span> <TT>rtm</TT> points to the <TT>rt_msghdr</TT> structure and <TT>sa</TT> points to the first socket address structure that follows.</p>
<p class="docText"><span class="docEmphasis"><TT>37</TT></span> <TT>rtm_addrs</TT> is a bitmask of which of the eight possible socket address structures follow the <TT>rt_msghdr</TT> structure. Our <TT>get_rtaddrs</TT> function (which we will show next) takes this mask plus the pointer to the first socket address structure (<TT>sa</TT>) and fills in the array <TT>rti_info</TT> with pointers to the corresponding socket address structures. Assuming that all four socket address structures shown in <A class="docLink" HREF="#ch18fig05">Figure 18.5</A> are returned by the kernel, the resulting <TT>rti_info</TT> array will be as shown in <A class="docLink" HREF="#ch18fig08">Figure 18.8</A>.</p>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch18fig08"></A>Figure 18.8. <TT>rti_info</TT> structure filled in by our <TT>get_rtaddrs</TT> function.</H5>

<p class="docText">
<IMG BORDER="0" id="129022115118" WIDTH="500" HEIGHT="415" src="FILES/18fig08.gif" ALT="graphics/18fig08.gif"></p>

</CENTER>
<P class="docText">Our program then goes through the <TT>rti_info</TT> array, doing what it wants with all the non-null pointers in the array.</P>
<p class="docText"><span class="docEmphasis"><TT>38–45</TT></span> Each of the four possible addresses are printed, if present. We call our <TT>sock_ntop_host</TT> function to print the destination address and the gateway address, but we call our <TT>sock_masktop</TT> to print the two masks. We will show this new function shortly.</p>
<P class="docText"><A class="docLink" HREF="#ch18fig09">Figure 18.9</A> shows our <TT>get_rtaddrs</TT> function that we called from <A class="docLink" HREF="#ch18fig07">Figure 18.7</A>.</P>

<A NAME="ch18lev3sec5"></A>
<H5 class="docSection3Title"> Loop through eight possible pointers</H5>
<p class="docText"><span class="docEmphasis"><TT>17–23</TT></span> <TT>RTAX_MAX</TT> is 8 in <A class="docLink" HREF="#ch18fig04">Figure 18.4</A>, the maximum number of socket address structures returned in a routing message from the kernel. The loop in this function looks at each of the eight <TT>RTA_</TT><span class="docEmphasis">xxx</span> bitmask constants from <A class="docLink" HREF="#ch18fig04">Figure 18.4</A> that can be set in the <TT>rtm_addrs</TT>, <TT>ifm_addrs</TT>, or <TT>ifam_addrs</TT> members of the structures in <A class="docLink" HREF="#ch18fig03">Figure 18.3</A>. If the bit is set, the corresponding element in the <TT>rti_info</TT> array is set to the pointer to the socket address structure; otherwise, the array element is set to a null pointer.</p>

<A NAME="ch18lev3sec6"></A>
<H5 class="docSection3Title"> Step to next socket address structure</H5>
<p class="docText"><span class="docEmphasis"><TT>2–12</TT></span> The socket address structures are variable-length, but this code assumes that each has an <TT>sa_len</TT> field specifying its length. There are two complications that must be handled. First, the two masks, the network mask and the cloning mask, can be returned in a socket address structure with an <TT>sa_len</TT> of 0, but this really occupies the size of an <TT>unsigned long</TT>. (Chapter 19 of TCPv2 discusses the cloning feature of the 4.4BSD routing table). This value represents a mask of all zero bits, which we printed as 0.0.0.0 for the network mask of the default route in our earlier example. Second, each socket address structure can be padded at the end so that the next one begins on a specific boundary, which in this case is the size of an <TT>unsigned long</TT> (e.g., a 4-byte boundary for a 32-bit architecture). Although <TT>sockaddr_in</TT> structures occupy 16 bytes, which requires no padding, the masks often have padding at the end.</p>

<H5 class="docExampleTitle"><A NAME="ch18fig09"></A>Figure 18.9 Build array of pointers to socket address structures in routing message.</H5>
<P class="docText"><span class="docEmphasis">libroute/get_rtaddrs.c</span></P>

<PRE>
 1 #include    "unproute.h"

 2 /*
 3  * Round up 'a' to next multiple of 'size', which must be a power of 2
 4  */
 5 #define ROUNDUP(a, size) (((a) &amp; ((size)-1)) ? (1 + ((a) | ((size)-1))) : (a))
 6 /*
 7  * Step to next socket address structure;
 8  * if sa_len is 0, assume it is sizeof(u_long).
 9  */
10 #define NEXT_SA(ap) ap = (SA *) \
11     ((caddr_t) ap + (ap-&gt;sa_len ? ROUNDUP(ap-&gt;sa_len, sizeof (u_long)) : \
12                                        sizeof(u_long)))
13 void
14 get_rtaddrs(int addrs, SA *sa, SA **rti_info)
15 {
16     int     i;

17     for (i = 0; i &lt; RTAX_MAX; i++) {
18         if (addrs &amp; (1 &lt;&lt; i)) {
19             rti_info[i] = sa;
20             NEXT_SA(sa);
21         } else
22             rti_info[i] = NULL;
23     }
24 }
</PRE>

<P class="docText">The last function that we must show for our example program is <TT>sock_masktop</TT> in <A class="docLink" HREF="#ch18fig10">Figure 18.10</A>, which returns the presentation string for one of the two mask values that can be returned. Masks are stored in socket address structures. The <TT>sa_family</TT> member is undefined, but the mask socket address structures do contain an <TT>sa_len</TT> of 0, 5, 6, 7, or 8 for 32-bit IPv4 masks. When the length is greater than 0, the actual mask starts at the same offset from the beginning as does the IPv4 address in a <TT>sockaddr_in</TT> structure: 4 bytes from the beginning of the structure (as shown in Figure 18.21, p. 577 of TCPv2), which is the <TT>sa_data[2]</TT> member of the generic socket address structure.</P>

<H5 class="docExampleTitle"><A NAME="ch18fig10"></A>Figure 18.10 Convert a mask value to its presentation format.</H5>
<P class="docText"><span class="docEmphasis">libroute/sock_masktop.c</span></P>

<PRE>
 1 #include    "unproute.h"

 2 const char *
 3 sock_masktop(SA *sa, socklen_t salen)
 4 {
 5     static char str[INET6_ADDRSTRLEN];
 6     unsigned char *ptr = &amp;sa-&gt;sa_data[2];

 7     if (sa-&gt;sa_len == 0)
 8         return ("0.0.0.0");
 9     else if (sa-&gt;sa_len == 5)
10         snprintf(str, sizeof(str), "%d.0.0.0", *ptr);
11     else if (sa-&gt;sa_len == 6)
12         snprintf(str, sizeof(str), "%d.%d.0.0", *ptr, *(ptr + 1));
13     else if (sa-&gt;sa_len == 7)
14         snprintf(str, sizeof(str), "%d.%d.%d.0", *ptr, *(ptr + 1),
15                  *(ptr + 2));
16     else if (sa-&gt;sa_len == 8)
17         snprintf(str, sizeof(str), "%d.%d.%d.%d",
18                  *ptr, *(ptr + 1), *(ptr + 2), *(ptr + 3));
19     else
20         snprintf(str, sizeof(str), "(unknown mask, len = %d, family = %d)",
21                  sa-&gt;sa_len, sa-&gt;sa_family);
22     return (str);
23 }
</PRE>

<p class="docText"><span class="docEmphasis"><TT>7–21</TT></span> If the length is 0, the implied mask is 0.0.0.0. If the length is 5, only the first byte of the 32-bit mask is stored, with an implied value of 0 for the remaining 3 bytes. When the length is 8, all 4 bytes of the mask are stored.</p>
<P class="docText">In this example, we want to read the kernel's reply because the reply contains the information we are looking for. But in general, the return value from our <TT>write</TT> to the routing socket tells us if the command succeeded or not. If that is all the information we need, we can call <TT>shutdown</TT> with a second argument of <TT>SHUT_RD</TT> immediately after opening the socket to prevent a reply from being sent. For example, if we are deleting a route, a return of 0 from <TT>write</TT> means success, while an error return of <TT>ESRCH</TT> means the route could not be found (p. 608 of TCPv2). Similarly, an error return of <TT>EEXIST</TT> from <TT>write</TT> when adding a route means the entry already exists. In our example in <A class="docLink" HREF="#ch18fig06">Figure 18.6</A>, if the routing table entry does not exist (say our host does not have a default route), then <TT>write</TT> returns an error of <TT>ESRCH</TT>.</P>



<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131411551_ch18lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131411551_ch18lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
